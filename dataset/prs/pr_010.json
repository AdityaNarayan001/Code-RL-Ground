{
  "pr_id": "PR-010",
  "title": "Add retry decorator with exponential backoff",
  "description": "Add a retry decorator to the decorators module that retries a function on exception. Should support max_retries, initial delay, and exponential backoff. Should re-raise the last exception if all retries fail.",
  "author": "dev-jack",
  "difficulty": 5,
  "depends_on": ["PR-009"],
  "labels": ["enhancement"],
  "files_changed": ["pyutils/decorators.py"],
  "base_commit": "bcd7890",
  "expected_tools": [
    {"tool": "read_file", "args": {"path": "pyutils/decorators.py"}},
    {"tool": "edit_file", "args": {"path": "pyutils/decorators.py", "content": "..."}}
  ],
  "expected_changes": {
    "pyutils/decorators.py": {
      "action": "modify",
      "additions": [
        "",
        "import time",
        "",
        "",
        "def retry(max_retries: int = 3, delay: float = 1.0, backoff: float = 2.0):",
        "    \"\"\"Decorator to retry function on exception with exponential backoff.",
        "    ",
        "    Args:",
        "        max_retries: Maximum number of retry attempts",
        "        delay: Initial delay between retries in seconds",
        "        backoff: Multiplier for delay after each retry",
        "        ",
        "    Returns:",
        "        Decorator function",
        "    \"\"\"",
        "    def decorator(func: Callable) -> Callable:",
        "        @wraps(func)",
        "        def wrapper(*args, **kwargs):",
        "            current_delay = delay",
        "            last_exception = None",
        "            ",
        "            for attempt in range(max_retries + 1):",
        "                try:",
        "                    return func(*args, **kwargs)",
        "                except Exception as e:",
        "                    last_exception = e",
        "                    if attempt < max_retries:",
        "                        time.sleep(current_delay)",
        "                        current_delay *= backoff",
        "            ",
        "            raise last_exception",
        "        return wrapper",
        "    return decorator"
      ]
    }
  },
  "test_cases": [
    {"description": "retry succeeds on first try", "test_code": "@retry(max_retries=3)\ndef always_works(): return 42\nassert always_works() == 42"},
    {"description": "retry retries on failure", "test_code": "attempts = 0\n@retry(max_retries=3, delay=0.01)\ndef fail_twice():\n    global attempts\n    attempts += 1\n    if attempts < 3: raise ValueError()\n    return 'ok'\nassert fail_twice() == 'ok'\nassert attempts == 3"},
    {"description": "retry raises after max retries", "test_code": "@retry(max_retries=2, delay=0.01)\ndef always_fails(): raise RuntimeError('fail')\ntry:\n    always_fails()\n    assert False\nexcept RuntimeError:\n    pass"}
  ],
  "success_criteria": {
    "must_compile": true,
    "tests_must_pass": true,
    "exact_match_bonus": true
  }
}
